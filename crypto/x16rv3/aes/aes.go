package aes

import (
	//	"encoding/binary"
	"log"
	//	"unsafe"
	//	"bytes"
	//	"reflect"
	//	"strconv"
	//	"fmt"
)

var sbox = []uint8{
	0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5, 0x30, 0x01, 0x67, 0x2B, 0xFE, 0xD7, 0xAB, 0x76,
	0xCA, 0x82, 0xC9, 0x7D, 0xFA, 0x59, 0x47, 0xF0, 0xAD, 0xD4, 0xA2, 0xAF, 0x9C, 0xA4, 0x72, 0xC0,
	0xB7, 0xFD, 0x93, 0x26, 0x36, 0x3F, 0xF7, 0xCC, 0x34, 0xA5, 0xE5, 0xF1, 0x71, 0xD8, 0x31, 0x15,
	0x04, 0xC7, 0x23, 0xC3, 0x18, 0x96, 0x05, 0x9A, 0x07, 0x12, 0x80, 0xE2, 0xEB, 0x27, 0xB2, 0x75,
	0x09, 0x83, 0x2C, 0x1A, 0x1B, 0x6E, 0x5A, 0xA0, 0x52, 0x3B, 0xD6, 0xB3, 0x29, 0xE3, 0x2F, 0x84,
	0x53, 0xD1, 0x00, 0xED, 0x20, 0xFC, 0xB1, 0x5B, 0x6A, 0xCB, 0xBE, 0x39, 0x4A, 0x4C, 0x58, 0xCF,
	0xD0, 0xEF, 0xAA, 0xFB, 0x43, 0x4D, 0x33, 0x85, 0x45, 0xF9, 0x02, 0x7F, 0x50, 0x3C, 0x9F, 0xA8,
	0x51, 0xA3, 0x40, 0x8F, 0x92, 0x9D, 0x38, 0xF5, 0xBC, 0xB6, 0xDA, 0x21, 0x10, 0xFF, 0xF3, 0xD2,
	0xCD, 0x0C, 0x13, 0xEC, 0x5F, 0x97, 0x44, 0x17, 0xC4, 0xA7, 0x7E, 0x3D, 0x64, 0x5D, 0x19, 0x73,
	0x60, 0x81, 0x4F, 0xDC, 0x22, 0x2A, 0x90, 0x88, 0x46, 0xEE, 0xB8, 0x14, 0xDE, 0x5E, 0x0B, 0xDB,
	0xE0, 0x32, 0x3A, 0x0A, 0x49, 0x06, 0x24, 0x5C, 0xC2, 0xD3, 0xAC, 0x62, 0x91, 0x95, 0xE4, 0x79,
	0xE7, 0xC8, 0x37, 0x6D, 0x8D, 0xD5, 0x4E, 0xA9, 0x6C, 0x56, 0xF4, 0xEA, 0x65, 0x7A, 0xAE, 0x08,
	0xBA, 0x78, 0x25, 0x2E, 0x1C, 0xA6, 0xB4, 0xC6, 0xE8, 0xDD, 0x74, 0x1F, 0x4B, 0xBD, 0x8B, 0x8A,
	0x70, 0x3E, 0xB5, 0x66, 0x48, 0x03, 0xF6, 0x0E, 0x61, 0x35, 0x57, 0xB9, 0x86, 0xC1, 0x1D, 0x9E,
	0xE1, 0xF8, 0x98, 0x11, 0x69, 0xD9, 0x8E, 0x94, 0x9B, 0x1E, 0x87, 0xE9, 0xCE, 0x55, 0x28, 0xDF,
	0x8C, 0xA1, 0x89, 0x0D, 0xBF, 0xE6, 0x42, 0x68, 0x41, 0x99, 0x2D, 0x0F, 0xB0, 0x54, 0xBB, 0x16}

var tmp [4][4]uint8

func Aes_enc_soft(a, b, roundKey []uint64) []uint64 {
	var temp, Tmp, Tm, t uint8

	for k := 0; k < 2; k++ {
		for i := 0; i < 2; i++ {
			for j := 0; j < 4; j++ {
				tmp[k*2+i][j] = uint8(b[k] >> uint(i*32+8*j))
			}
		}
	}

	// Rotate first row 1 columns to left
	temp = tmp[0][1]
	tmp[0][1] = tmp[1][1]
	tmp[1][1] = tmp[2][1]
	tmp[2][1] = tmp[3][1]
	tmp[3][1] = temp

	// Rotate second row 2 columns to left
	temp = tmp[0][2]
	tmp[0][2] = tmp[2][2]
	tmp[2][2] = temp

	temp = tmp[1][2]
	tmp[1][2] = tmp[3][2]
	tmp[3][2] = temp

	// Rotate third row 3 columns to left
	temp = tmp[0][3]
	tmp[0][3] = tmp[3][3]
	tmp[3][3] = tmp[2][3]
	tmp[2][3] = tmp[1][3]
	tmp[1][3] = temp

	for i := 0; i < 4; i++ {
		for j := 0; j < 4; j++ {
			tmp[j][i] = sbox[tmp[j][i]]
		}
	}

	for i := 0; i < 4; i++ {
		t = tmp[i][0]
		Tmp = tmp[i][0] ^ tmp[i][1] ^ tmp[i][2] ^ tmp[i][3]
		Tm = tmp[i][0] ^ tmp[i][1]
		Tm = ((Tm << 1) ^ (((Tm >> 7) & 1) * 0x1b))
		tmp[i][0] ^= Tm ^ Tmp
		Tm = tmp[i][1] ^ tmp[i][2]
		Tm = ((Tm << 1) ^ (((Tm >> 7) & 1) * 0x1b))
		tmp[i][1] ^= Tm ^ Tmp
		Tm = tmp[i][2] ^ tmp[i][3]
		Tm = ((Tm << 1) ^ (((Tm >> 7) & 1) * 0x1b))
		tmp[i][2] ^= Tm ^ Tmp
		Tm = tmp[i][3] ^ t
		Tm = ((Tm << 1) ^ (((Tm >> 7) & 1) * 0x1b))
		tmp[i][3] ^= Tm ^ Tmp
	}

	a[0] = uint64(tmp[0][0]) | (uint64(tmp[0][1]) << 8) | (uint64(tmp[0][2]) << 16) | (uint64(tmp[0][3]) << 24) | (uint64(tmp[1][0]) << 32) | (uint64(tmp[1][1]) << 40) | (uint64(tmp[1][2]) << 48) | (uint64(tmp[1][3]) << 56)
	a[1] = uint64(tmp[2][0]) | (uint64(tmp[2][1]) << 8) | (uint64(tmp[2][2]) << 16) | (uint64(tmp[2][3]) << 24) | (uint64(tmp[3][0]) << 32) | (uint64(tmp[3][1]) << 40) | (uint64(tmp[3][2]) << 48) | (uint64(tmp[3][3]) << 56)

	a[0] ^= roundKey[0]
	a[1] ^= roundKey[1]
	return a
}

var input = [...]uint64{
	0x020000008d870b41, 0x404883ac195d9920, 0x1225a41dd77969a6, 0x8374e68ec8ee7500,
	0x00000000a2123af0, 0x394e7606b5fec3cb, 0x96ddeea4d1d376ac, 0xc0daeb202c5fc670,
	0x6c5bb067c7044a53, 0xe3e6001c00104d49, 0x1c5bb367c7024a33, 0xb3e3003c40105d49,
	0x020000008d870b41, 0x404883ac195d9920, 0x1225a41dd77969a6, 0x8374e68ec8ee7500,
	0x00000000a2123af0, 0x394e7606b5fec3cb, 0x96ddeea4d1d376ac, 0xc0daeb202c5fc670,
	0x6c5bb067c7044a53, 0xe3e6001c00104d49, 0x1c5bb367c7024a33, 0xb3e3003c40105d49,
}

var key = [...]uint64{
	0xb3e3003c40105d49, 0x020000008d870b41, 0x404883ac195d9920, 0x1225a41dd77969a6,
	0x8374e68ec8ee7500, 0x00000000a2123af0, 0x394e7606b5fec3cb, 0x96ddeea4d1d376ac,
	0xc0daeb202c5fc670, 0x6c5bb067c7044a53, 0xe3e6001c00104d49, 0x1c5bb367c7024a33,
	0xb3e3003c40105d49, 0x020000008d870b41, 0x404883ac195d9920, 0x1225a41dd77969a6,
	0x8374e68ec8ee7500, 0x00000000a2123af0, 0x394e7606b5fec3cb, 0x96ddeea4d1d376ac,
	0xc0daeb202c5fc670, 0x6c5bb067c7044a53, 0xe3e6001c00104d49, 0x1c5bb367c7024a33,
}

var golden = [...]uint64{
	0x102d0fdce373c5b4, 0x511bb6f35a6b317b, 0xa45ca5dfd74fbb77, 0x3498fde8c3a30596,
	0x5329922fbb5afb0f, 0xe34d04f3b419762c, 0x7d5f8b3a9517f2ff, 0x4f580029960cd4d8,
	0xaeeafc470fe9aa58, 0xfac6b37fbb53ea22, 0xbd5ce80e23867cc4, 0xc70fadfbbd0bb20b,
	0x102d0fdce373c5b4, 0x511bb6f35a6b317b, 0xa45ca5dfd74fbb77, 0x3498fde8c3a30596,
	0x5329922fbb5afb0f, 0xe34d04f3b419762c, 0x7d5f8b3a9517f2ff, 0x4f580029960cd4d8,
	0xaeeafc470fe9aa58, 0xfac6b37fbb53ea22, 0xbd5ce80e23867cc4, 0xc70fadfbbd0bb20b,
}

func main() {
	out := make([]uint64, 24)

	log.Println("do aes test...")

	for i := 0; i < 12; i++ {
		Aes_enc_soft(out[i*2:], input[i*2:], key[i*2:])
	}

	var pass bool = true

	for i := 0; i < 24; i++ {
		if out[i] != golden[i] {
			pass = false
			break
		}
	}

	if pass {
		log.Println("test OK!!!")
	} else {
		log.Println("test ERROR!!!")
	}

	log.Println("==============================================\n")

}
